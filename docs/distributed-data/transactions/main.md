## 深入理解事务
事务作为一个抽象层，使得应用程序可以忽略数据库内部一些复杂的并发问题，以及某些硬件，软件故障，从而简化应用层逻辑，大量的错误可以简化为事务中止和重试。
如果没有事务，各种错误（如进程崩溃，网络中断，停电，磁盘已满，并发竞争等）会导致数据可能出现各种不一致情况。

#### ACID 的含义
事务所提供的安全保证即`ACID`，分别代表原子性（Atomicity），一致性（Consistency），隔离性（Isolation），持久性（Durability）。
不过实际上，各家数据库所实现的`ACID`不尽相同，而不符合`ACID`标准的系统有时被冠以`BASE`，即基本可用性（Basically Available），软状态（Soft state）
和最终一致性（Eventual consistency）。

###### 原子性 
`ACID`中原子性的定义为：在出错时中止事务，并将部分完成的写入全部丢弃。（也许可中止性比原子性更为准确）

###### 一致性 
`ACID`中一致性主要指对数据有特定的预期状态，任何的数据更改必须满足这些预期状态。

比如银行账户，收入和支出保持平衡。如果事务从一个有效状态开始，并且事务中任何更新操作都没有违背约束，那么最后的结果依然符合有效状态。这种一致性实际上
需要在应用层进行维护，因为数据库很难检测出来数据是否是预期的状态。

###### 隔离性 
`ACID`语义中的隔离性意味着并发执行的多个事务之间相互隔离，互不影响。

###### 持久性 
数据库系统本质上是提供一个安全可靠的地方来存储数据而不用担心数据丢失等。`持久性`就是这样的承诺，它保证一旦事务提交成功，即使存在硬件故障或数据库
崩溃，事务所写入的任何数据也不会丢失。

#### 单对象与多对象事务操作
###### 单对象写入
原子性和隔离性适用于单个对象的更新。例如向数据库写入 200KB 的`JSON`文档：
* 如果发送了第一个 10KB 之后网络连接中断，数据库是否只存储了无法解析的 10KB `JSON`片段？
* 如果数据库在覆盖磁盘现有数据时发生电源故障，最终是否是新旧值混杂在一起？
* 如果在另一个客户端写入时读取该文档，是否会看到部分更新的文档内容？

这些问题非常难搞，因此存储引擎在设计时必备的设计就是在单节点，单对象层面实现`原子性`和`隔离性`。例如在出现宕机时，基于日志恢复来实现原子性；对每个
对象采用加锁的方式（每次只允许一个线程访问）来实现隔离。

###### 多对象事务的必要性
很多的分布式数据库不支持多对象事务，主要因为当出现跨分区时，多对象事务难以正确实现，同时在高可用或者极致性能的场景下也会带来很多负面影响。但是
分布式事务并非无法实现!

多对象事务场景：
* 对于关系型数据库，表中的某列可能是另一个表中的外键。多对象事务用来确保这些外键引用的有效性，即当插入多个相互引用的记录时，保证外键总是最新的，
  正确的，否则数据更新没有任何意义。
* 对于文档型数据库，经常反`范式化`。更新这类数据时通常需要更新多个文档。
* 对于带有二级索引的数据库，每次更新值时都需要同步更新索引，从事务的角度看这些索引就是不同的数据库对象。如果没有事务隔离，就会出现索引部分更新。

###### 处理错误与终止
事务的另一个关键特征是：如果发生了意外，所有操作被中止，之后可以安全的重试。    
`ACID`数据库基于这样一个理念：如果存在违反原子性，隔离性或持久性的风险，则完全放弃整个事务，而不是部分放弃。

## 弱隔离级别
当某个事务修改数据而另一个事务要读取该数据，或者两个事务同时修改同一个数据时，会引发并发问题。这类问题很难复现，也并不容易修复。因此，数据库一直
尝试通过事务隔离来对应用开发者隐藏数据库内部的各种并发问题。

然而隔离并不容易。可串行化的隔离严重影响性能，然而许多的数据库并不愿意牺牲性能，因此更多的采用了较弱的隔离级别。它可以避免某些但非全部的并发问题。

#### 提交读
提交读的事务隔离级别，它只提供以下两个保证：
1. 读取数据库时，只能看到已成功提交的内容（防止脏读）
1. 写数据库时，只能覆盖已成功提交的内容（防止脏写）

###### 防止脏读
脏读定义：能够读取到未成功提交的内容，称为脏读。

提交读级别的事务隔离必须做到防止脏读，即事务的任何写入只有在成功提交后，才能被其它人观察到（并且所有的写全部可见）

当有以下需求时，需要防止脏读：
1. 如果事务需要更新多个对象，脏读意味着另一个事务可能会看到部分更新，而非全部。
2. 如果事务发生中止，则所有写入都需要回退。如果发生了脏读，这意味着会看到稍后需要回滚的数据，这些数据并未实际提交到数据库中。

###### 防止脏写
脏写定义：前后两次写入，后面的写入会覆盖掉前面尚未提交的写入。

提交读级别的事务隔离必须做到防止脏写，通常的方式是推迟第二个写请求，直到前面的事务提交或中止。

###### 实现提交读
数据库通常使用行级锁来防止脏写，当事务想修改某个对象（例如行或文档）时，它必须获取该对象的锁，然后一直持有锁直到事务提交或中止。同一时刻只有一个事务
可以获得该对象的锁，如果有另一个事务尝试更新同一对象，则必须等待前面的事务提交或中止（即释放锁）。

数据库防止脏读有两种方式：
1. 使用与防止脏写相同的锁。缺点很明显，性能太差。
2. 对于每个待更新的对象，数据库会维护其旧值和当前持有锁的事务将要设置的新值这两个版本。在事务提交之前，所有的读操作都读取旧值；仅当事务提交之后，
   才会读取新值。

#### 快照隔离级别和可重复读
快照隔离的核心思想是：每个事务都从一个数据库的快照中读数据，保证重复多次读取的内容是一致的。（即：事务看到的所有数据，都是在事务开始的时间点之前提交的数据）  
如果有些数据在当前事务开始之后，被其他事务改变了值，快照隔离能够保证当前事务无法看到这个新值。

很多数据库对快照隔离的命名不同，比如：
* `Oracle`称之为：可序列化 (Serializable)。
* `PostgreSQL`和`MySQL`称之为：可重复读 (Repeatable Read) 或 快照隔离 (Snapshot Isolation)

###### 实现快照隔离级别
为了实现快照级别隔离，考虑到多个同时进行的事务可能会在不同的时间点查看数据库状态，所以数据库保留了对象多个不同的提交版本，这种技术也称为
**多版本并发控制（MVCC）**。

支持快照级别的存储引擎通常采用`多版本并发控制`来实现`提交读`。典型做法是对每一个不同的**查询**单独创建一个快照，只保留对象的 2 个版本，即`已提交的旧版本`
和`未提交的新版本`。 而快照隔离级别使用一个快照来运行整个事务。

当事务开始时，为这个事务分配一个独一无二的事务`ID`。每当事务向数据库写入数据时，数据里面会加上`事务ID`。表中每一行数据都有一个`craete_by`字段，里面
的值是创建该行的`事务ID`；每一行还有`delete_by`字段，值是删除该行的`事务ID`。当数据库确认没有其它的事务引用标记删除的行时，数据库的垃圾回收进程
会去执行真正地删除操作并释放内存空间。另外，数据库并不会真正执行更新操作，而是先删除旧数据再创建新数据。

###### 一致性快照的可见性规则
1. 每笔事务开始时，数据库列出所有正在进行中的其它事务，然后忽略这些事务的部分写入，即不可见。
2. 所有中止事务所做的修改全部不可见
3. 晚于当前事务所做的任何修改不可见，无论这些事务是否已经完成
4. 除此之外，其它所有的写入都应可见

###### 索引与快照隔离级别
多版本并发控制（MVCC）如何适配索引？有两种常见的方案：
1. 索引指向对象的所有版本，然后过滤掉对当前事务不可见的版本。当后台垃圾回收某个旧对象的版本时，对应的索引也随之被删除。
2. 对于`B-tree`结构的索引，采用追加/写时复制技术。当需要更新索引时，不会修改磁盘当前页面，而是创建一个新的修改副本，拷贝必要的内容，然后指向
   `root` 节点。

#### 防止更新丢失
更新丢失可能会发生在这种场景下：2 个写事务同时对一个初始值为 0 的字段进行自增操作。我们期待最终的结果为 2。但是实际上最终结果可能是 1。 

###### 原子写操作
许多数据库提供了原子写操作，以避免在应用层代码完成`读-修改-写回`操作，如果数据库支持的话，通常这是最好地解决方案。

原子操作通常采用对读取对象加独占锁的方式实现，这样在更新操作提交之前其它事务无法读取该对象。另一种实现方式是强制所有的原子操作都是单线程的。

###### 显示加锁
如果数据库不支持原子操作，那么应用层也可以显示的对对象加锁。即对`读取-修改-写回`操作加锁。

###### 自动检测更新
数据库原子操作和应用层加锁都是通过将`读-修改-写回`操作序列串行执行来防止更新。另外一种思路是先让它们并发执行，当事务管理器检测到数据更新丢失
风险，则会中止当前事务，并强制回退到安全的`读-修改-写回`方式。

该方式的一个优点是数据库完全可以借助快照级别隔离来高效的执行检查。

###### 原子比较和设置
在不提供事务支持的数据库中，有的支持原子`CAS`操作。使用该操作可以避免更新丢失，即在set时判断数据是否发生过变化，如果已经发生了变化，
则进行重试。

###### 冲突解决与复制 
加锁和原子修改都有一个前提即只有一个最新的数据副本。然而对于无主节点或多主节点这种多副本数据库来说，由于支持多个并发写，并且通常以异步方式来同步
更新数据，所以会出现多个最新的数据副本。此时加锁和原子比较不再适用。

#### 写倾斜与幻读
当多个事务同时修改同一对象时引发了两种竞争条件，即脏写和更新丢失。为了避免这种情况可以借助数据库的内置机制或采取手动加锁，执行原子操作等。然后这并不是
并发写所引发的所有问题，还有更为微妙地写冲突。

事务读取了某些符合查询条件的对象，同时另一个客户端执行写入，改变了先前的查询结果。快照隔离可以防止简单的幻读，但写倾斜需要特殊处理，例如采用区间范围锁。

###### 写倾斜
设想这样一个例子：医院有一个轮班系统，规定夜班至少要有一名医生在值班。当需要值夜班的 A，B 两名医生都想请假，他们同时提交了请假申请，此时会发生什么？
请假事务的流程为：首先检查是否有其他医生在值班，如果有则可以成功请假。由于数据库正在使用快照级别隔离，因此两个检查都返回有两名医生，所以两个事务都安全
的进入到下一阶段。接下来 A 更新自己的值班记录为请假离开，B 也更新自己的值班记录为请假离开。最后没有任何医生在值班，这显然违背了至少要有一名医生值班的要求。

上述的这种情况称为`写倾斜`。它既不是脏写也不是更新丢失，两笔事务更新的是不同的对象，写冲突并不直接，但是他们却有着一定的逻辑关系。如果两笔事务是
串行执行，就不会出现异常。

写倾斜定义：事务首先查询数据，根据返回的结果而做出某些决定，然后修改数据库。当事务提交时，支持决定的前提条件已不再成立。只有可串行化能够防止这种异常。

## 串行化
可串行化隔离是最强的隔离级别，它可以防止所有的竞争条件，保证并行执行的结果和串行执行一致。

#### 实际串行执行
解决并发问题最直接的方法是避免并发：即在一个线程上按顺序每次执行一个事务。这样就避免了检测冲突，防止事务冲突等问题，其隔离界别一定是严格串行化的。

###### 分区
串行执行所有事务使得并发控制更加简单，但是数据库的吞吐量被限制在单机单个`CPU`核。虽然只读事务可以在单独的快照上执行，但是对于那些高写入需求的应用程序，
单线程事务处理很容易造成严重的瓶颈。

为了扩展到多个`CPU`核和多节点，可以对数据进行分区。使得每个事务只在单个分区读写数据，这样每个分区都可以有自己的事务处理线程且独立运行。此时为每个
`CPU`核分配一个分区，那么数据库的总体事务吞吐量可以达到与`CPU`核数成正比关系。但是对于跨分区的事务，数据库必须在涉及的所有分区之间协调事务。另外
由于跨分区事务需要额外的协调开销，所以它的性能比单分区事务要慢得多。

###### 串行执行小结
当满足以下约束条件时，串行执行事务可以实现串行化隔离：
* 事务必须简单而高效，否则一个缓慢的事务会影响到其它事务的执行效率。
* 仅限于数据可以完全加载到内存的场景。有些很少访问的数据可能被移动到磁盘，万一单线程事务需要访问它，就会严重拖累性能。
* 写入吞吐量必须足够低，才能在单个`CPU`核上处理；否则就需要采用分区，最好没有跨分区事务。
* 跨分区事务可以支持，但是比例一定要小。

#### 两阶段加锁
数据库有一种被广泛使用的串行化算法，即两阶段加锁（two-phase locking，2PL）

之前提到过，可以通过对对象加锁的方式来防止脏写。即如果两个事务同时尝试修改同一个对象时，以加锁的方式来确保后面的事务必须等待前面的事务完成之后才能开始。
两阶段加锁方法类似，但是锁的强制性更高。多个事务可以同时读取同一个对象，但是只要出现任何写操作，则必须加锁以独占访问。类似`JAVA`的读锁和写锁，读读不互斥，
读写互斥，写写互斥。

快照隔离级别和两阶段加锁的区别就是快照隔离级别读写互不干扰。另一方面，因为两阶段加锁提供了串行化，所以它可以防止前面提到的所有竞争条件，包括更新丢失
和写倾斜。

两阶段加锁指的是：事务在修改或读取数据时分为两个阶段，第一阶段获取锁并执行事务，第二阶段释放锁。

###### 实现两阶段加锁
数据库中每一个对象都有一个共享的读锁和一个独占的写锁，基本用法如下：
* 如果事务需要读取对象，需要先获取读锁。多个事务可以获取同一把读锁。
* 如果事务要修改对象，必须先获取写锁。写锁是独占的，同一时间只能有一个事务持有。
* 如果一个事务已经获得了对象的写锁，则其它事务必须等待。
* 如果事务先读取对象，然后尝试写入对象，则需要将读锁升级为写锁。
* 事务获取锁之后，一直持有直到事务结束。

由于采用了较复杂的锁机制，因此很容易出现死锁。数据库会自动检测事务的死锁情况，并强制中止其中一个以打破僵局，这样另一个就可以继续向前执行，而被中止
的事务需要由应用层来重试。

###### 两阶段加锁的性能
两阶段加锁的性能很差，主要原因是其降低了事务的并发性并且锁的释放和获取开销也很大。另外两阶段加锁的数据库性能很不稳定，当某个事务本身很慢并且其对大量
数据都加了锁，那么会阻塞很多其它的事务。

###### 谓词锁
谓词锁类似两阶段加锁，区别是它并不属于某个对象，而是作用于满足某些搜索条件的所有查询对象。

谓词锁可以保护数据库中那些尚不存在但是可能马上会被插入的对象（幻读）。将两阶段加锁和谓词锁结合使用，数据库可以防止所有形式的写倾斜和其它竞争条件，
使隔离变得真正地可串行化。

当然谓词锁的性能也十分地差。

###### 索引区间锁
因为谓词锁性能很差，如果活动的事务中存在很多锁，那么检查匹配这些锁就变得非常耗时。因此大部分使用两阶段加锁的数据库实际上使用的都是索引区间锁，本质上
它是对谓词锁的简化或近似。

简化谓词锁的方式是扩大其保护的对象（减少锁的数量）。如果一个谓词锁保护的查询条件是：房间123，时间段是 1 点到 2 点，一种方式是扩大时间段来简化，即保护房间123的所有
时间段；另一种是扩大房价，即保护 1 点到 2 点的所有房间。这样任何与谓词锁冲突的操作肯定也和区间锁冲突。

例如：有一个房间预定数据库，在`room_id`列上加索引，数据库使用此索引查询房价123的当前预定情况时，会将共享的读锁附加到该索引上，
表明事务已经所有了房间123的所有时段预定。此时，如果另一个事务想要写或更新对象，则需要更新索引，那么一定会与共享读锁发生冲突，因此处于阻塞状态直到
共享读锁的释放。

这样就有效防止了写倾斜和幻读，它索然不像谓词锁那么精确（会锁定更大范围的对象），但是由于开销要低得多，也是一种不错的这种方案。

#### 可串行化快照隔离
两阶段锁虽然可以保证串行化，但是性能很差；弱级别隔离虽然性能不错，但是容易引发各种边界条件（如更新丢失，写倾斜，幻读等）。另外一种称为`可串行化快照隔离`
的算法能够提供可串行化的保证，而且性能相比快照隔离损失很小。

###### 悲观与乐观地并发控制
两阶段加锁是一种典型的悲观锁，它假设可能出现并发冲突的事务就一定会出现并发冲突，因此必须通过加锁来保证没有冲突。相比之下，可串行化快照隔离则是一种
乐观并发控制。在这种情况下，如果有潜在的冲突，事务会继续执行，假定冲突不会发生。当事务提交时，数据库会检查是否发生了冲突，如果是的话，中止事务并重试。

如果冲突很多，乐观锁的性能不佳，因为会频繁地中止并重试。如果数据库已接近最大吞吐量，此时反复的重试事务会使系统性能变得更差。但是如果系统还有足够的
性能提升空间，且事务之间的竞争不大，那么乐观并发控制会比悲观并发控制高效的多。

###### 基于过期的条件做决定
之前讨论写倾斜时，介绍了这样一种使用场景：事务首先查询某些数据，根据查询的结果来决定采取后续操作，例如修改数据。而在快照隔离情况下，数据可能在查询期间就
已被其他事务修改，导致原事务在提交决策时依据信息已出现变化。

换句话说，事务是基于某些前提条件而采取相应的行动，在事务开始时条件成立，而当事务要提交时，数据可能发生了变化，条件已不再存在。

当应用程序执行查询时，数据库本身并不知道应用层逻辑如何使用这些查询结果。安全起见，数据库假定对查询结果的任何变化都应该使写事务失效。**也就是说，查询与
写事务之间有可能存在因果依赖关系。为了提供可串行化的隔离，数据库必须检测事务是否会修改其它事务的查询结果，并在此情况下中止写事务**。

###### 检测是否读取了过期的 MVCC 对象
快照隔离通常采用多版本并发控制技术（MVCC）来实现。当事务从 MVCC 数据库一致性快照读取数据时，它会忽略那些在创建快照时尚未提交的事务写入。当写入事务
提交时，数据库会检查该数据是否和快照的数据有冲突，如果有则中止当前写入事务。

###### 检测是否影响了之前的读
还拿值班系统举例子，A 和 B 两个医生都想请假，但是医院规定每天至少要有一人值班，即不能 A，B 两个人都请假。事务 A 和 B 同时查询数据库，发现符合条件
自己可以请假。接着 A 先修改值班表，将自己的值班字段`on-call`设为 false，索引或表级别会记录下 A 的修改。当 B 尝试修改自己的值班记录提交事务时，他会先查询
索引，发现数据被修改了，有冲突。B 的事务不得不中断并且重试。

###### 可串行化快照隔离的性能
与两阶段加锁相比，可串行化隔离的一大优点是事务不需要等待其它事务所持有的锁。这一点和快照隔离一样，读写通常不会相互阻塞。这样的设计使得延迟查询更加稳定
和可预测。特别是，在一次性快照上执行只读查询不需要任何锁，对于读密集的负载非常有吸引力。













