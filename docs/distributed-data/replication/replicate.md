#### 复制滞后问题
在主从复制中，一般不会采用同步复制。因为在同步复制中，当一个从节点故障时整个系统都无法写入且从节点越多出现故障的概率就越高。

#### 最终一致性
因为主从节点的复制滞后，从节点的数据可能会落后于于主节点使得主机点和从节点数据不一致。不过这种不一致只是一个暂时的状态，当停止写数据库，
经过一段时间后从节点最终会追赶上并于主节点保持一致。这种效应成为`最终一致性`

正常情况下主节点和从节点的复制滞后可能不足 1 秒，这样的滞后在实践中一般不会有什么问题。不过当系统已达到设计上限或存在网络问题，那么
复制滞后很容易增加到数十秒甚至几分钟不等。

当滞后的时间过长时，导致的不一致性会引发很多的问题。下文中会介绍三个复制滞后可能会出现的问题，并给出相应的解决思路。

#### 读自己写
在异步复制中可能会存在这样一个问题：用户查询不到自己刚刚写入到数据库的内容。这是因为用户实际上是在滞后于主节点的副本上执行查询操作，
此时副本还未同步主节点的数据。对于这种情况需要`读写一致性`来保证总是能够读到自己刚刚的写入。

基于主从复制的系统有多种方式来保证读写一致性：
1. 如果用户访问的是可能会被修改的内容，那么从主节点读取
2. 如果大部分的数据都可能会被修改，那么上述的方案就不适用了。需要通过其它的方法来判断是否从主节点读取数据。如：数据更新后 1 分钟之内从
   主节点读取数据

#### 单调读
用户从不同副本进行了多次读取，有可能每次读取的结果都不一致。因为每次读取的都是不同的副本，并且每个副本的滞后程度都不同。 单调读一致性
可以确保不会发生这种异常。这是一种比强一致性若，但是比最终一致性强的保证。

单调读保证，如果某个用户依次进行多次读取，则他绝对不会看到回滚现象。即在读取到新值之后下次读取又能够读到旧值。

实现单调读的一直方式是：确保每个用户总是固定的从一个副本读取数据。

#### 前缀一致读
对于一系列按照某个顺序发生的写请求，那么读取这些内容时也会按照当时写入的顺序。

如果数据库总是以相同的顺序写入，那么读取时总是与写入顺序保持一致。然而在许多的分布式数据库中，不同的分区独立运行，因此不存在全局
写入顺序，这就导致了读取数据时可能会读取到旧值。

前缀一致读保证读取数据的顺序和写入顺序保持一致。